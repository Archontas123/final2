package com.tavuc.managers;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.HashMap;
import java.util.Map;

import com.tavuc.models.entities.Player;
import com.tavuc.models.space.Ship;
import com.tavuc.networking.models.FireRequest;
import com.tavuc.Client; 

/**
 * A singleton manager for handling all keyboard input.
 */
public class InputManager implements KeyListener {

    /**
     * The singleton instance of the InputManager.
     */
    private static InputManager instance;
    /**
     * A map that tracks the current state of keyboard keys.
     */
    private Map<Integer, Boolean> keyStates = new HashMap<>();

    /**
     * Provides synchronized access to the singleton instance of the InputManager.
     * @return The single instance of InputManager.
     */
    public static synchronized InputManager getInstance() {
        if (instance == null) instance = new InputManager();
        return instance;
    }

    /**
     * An enumeration to specify the type of entity being controlled by the input manager.
     */
    public enum ControlTargetType {
        /** Indicates that the input should control a Player entity. */
        PLAYER,
        /** Indicates that the input should control a Ship entity. */
        SHIP
    }

    /**
     * The current type of entity being controlled.
     */
    private ControlTargetType controlTargetType;
    /**
     * The Player entity currently being controlled. Null if the target is not a Player.
     */
    private Player player; 
    /**
     * The Ship entity currently being controlled. Null if the target is not a Ship.
     */
    private Ship ship; 
    /**
     * Flags indicating the state of movement keys.
     */
    private boolean upPressed, downPressed, leftPressed, rightPressed;

    /**
     * Private constructor to enforce the singleton pattern. 
     */
    private InputManager() {
        this.controlTargetType = ControlTargetType.PLAYER; 
    }

    /**
     * Sets the type of entity that the input manager should control.
     * Setting a new target type will nullify the reference to the previous target entity.
     * @param type The new control target type.
     */
    public void setControlTarget(ControlTargetType type) {
        this.controlTargetType = type;
        if (type != ControlTargetType.PLAYER) {
            this.player = null;
        }
        if (type != ControlTargetType.SHIP) {
            this.ship = null;
        }
    }

    /**
     * Sets the specific Player instance to be controlled by this input manager.
     * @param player The Player entity to control.
     */
    public void setPlayerTarget(Player player) {
        this.player = player;
    }

    /**
     * Sets the specific Ship instance to be controlled by this input manager.
     * @param ship The Ship entity to control.
     */
    public void setShipTarget(Ship ship) {
        this.ship = ship;
    }


    /**
     * This method is part of the KeyListener interface.
     * @param e The KeyEvent generated by a key being typed.
     */
    @Override
    public void keyTyped(KeyEvent e) {}

    /**
     * Handles key press events. It updates the internal state of pressed keys and
     * applies the corresponding action to the currently controlled entity).
     * @param e The KeyEvent generated by a key being pressed.
     */
    @Override
    public void keyPressed(KeyEvent e) {
        keyStates.put(e.getKeyCode(), true);
        int keyCode = e.getKeyCode();

        if (controlTargetType == ControlTargetType.SHIP && ship != null) {
            if (keyCode == KeyEvent.VK_W || keyCode == KeyEvent.VK_UP) {
                upPressed = true; 
                ship.setThrusting(true);
            }
            if (keyCode == KeyEvent.VK_A || keyCode == KeyEvent.VK_LEFT) {
                leftPressed = true;
                ship.setRotationInput(-1.0);
            }
            if (keyCode == KeyEvent.VK_D || keyCode == KeyEvent.VK_RIGHT) {
                rightPressed = true;
                ship.setRotationInput(1.0);
            }
        } else if (controlTargetType == ControlTargetType.PLAYER) {
            if (keyCode == KeyEvent.VK_W || keyCode == KeyEvent.VK_UP) upPressed = true;
            if (keyCode == KeyEvent.VK_S || keyCode == KeyEvent.VK_DOWN) downPressed = true;
            if (keyCode == KeyEvent.VK_A || keyCode == KeyEvent.VK_LEFT)  leftPressed = true;
            if (keyCode == KeyEvent.VK_D || keyCode == KeyEvent.VK_RIGHT) rightPressed = true;
            updatePlayerMovementInput();
        }
    }

    /**
     * Handles key release events. It updates the internal state of pressed keys and
     * stops the corresponding action for the currently controlled entity.
     * @param e The KeyEvent generated by a key being released.
     */
    @Override
    public void keyReleased(KeyEvent e) {
        keyStates.put(e.getKeyCode(), false);
        int keyCode = e.getKeyCode();

        if (controlTargetType == ControlTargetType.SHIP && ship != null) {
            if (keyCode == KeyEvent.VK_W || keyCode == KeyEvent.VK_UP) {
                upPressed = false;
                ship.setThrusting(false);
            }
            if (keyCode == KeyEvent.VK_A || keyCode == KeyEvent.VK_LEFT) {
                leftPressed = false;
                if (rightPressed) { 
                    ship.setRotationInput(1.0);
                } else {
                    ship.setRotationInput(0.0);
                }
            }
            if (keyCode == KeyEvent.VK_D || keyCode == KeyEvent.VK_RIGHT) {
                rightPressed = false;
                if (leftPressed) { 
                    ship.setRotationInput(-1.0);
                } else {
                    ship.setRotationInput(0.0);
                }
            }
        } else if (controlTargetType == ControlTargetType.PLAYER && player != null) {
            if (keyCode == KeyEvent.VK_W || keyCode == KeyEvent.VK_UP) upPressed = false;
            if (keyCode == KeyEvent.VK_S || keyCode == KeyEvent.VK_DOWN) downPressed = false;
            if (keyCode == KeyEvent.VK_A || keyCode == KeyEvent.VK_LEFT) leftPressed = false;
            if (keyCode == KeyEvent.VK_D || keyCode == KeyEvent.VK_RIGHT) rightPressed = false;
            updatePlayerMovementInput();
        }
    }

    /**
     * Checks if a specific key is currently being held down.
     * @param keyCode The virtual key code for the key to check.
     * @return {@code true} if the key is currently pressed, {@code false} otherwise.
     */
    public boolean isKeyPressed(int keyCode) {
        return keyStates.getOrDefault(keyCode, false);
    }

    /**
     * Updates the controlled player's movement vector and acceleration based on the
     * current state of the movement keys (WASD). 
     */
    private void updatePlayerMovementInput() {
        if (player == null || controlTargetType != ControlTargetType.PLAYER) {
            return; 
        }

        double vecX = 0.0;
        double vecY = 0.0;
        double angle = player.getDirection();

        if (upPressed && !downPressed) {
            vecX += Math.cos(angle);
            vecY += Math.sin(angle);
        }
        if (downPressed && !upPressed) {
            vecX -= Math.cos(angle);
            vecY -= Math.sin(angle);
        }
        if (leftPressed && !rightPressed) {
            vecX += Math.cos(angle - Math.PI / 2);
            vecY += Math.sin(angle - Math.PI / 2);
        }
        if (rightPressed && !leftPressed) {
            vecX += Math.cos(angle + Math.PI / 2);
            vecY += Math.sin(angle + Math.PI / 2);
        }

        boolean moving = vecX != 0 || vecY != 0;

        if (moving) {
            player.setMoveVector(vecX, vecY);
            player.setAcceleration(1.0);
        } else {
            player.setMoveVector(0, 0);
            player.setAcceleration(0.0);
        }
    }

    /**
     * Gets the Player entity currently being controlled by this InputManager.
     * @return The Player object, or {@code null} if the control target is not a Player.
     */
    public Player getPlayer() {
        return player;
    }

    /**
     * Gets the Ship entity currently being controlled by this InputManager.
     * @return The Ship object, or {@code null} if the control target is not a Ship.
     */
    public Ship getShip() {
        return ship;
    }

    /**
     * Programmatically simulates a key press event. For Testing/AI
     * @param keyCode The virtual key code of the key to simulate pressing.
     */
    public void simulateKeyPress(int keyCode) {
        KeyEvent keyEvent = new KeyEvent(new java.awt.Component(){}, KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, keyCode, KeyEvent.CHAR_UNDEFINED);
        this.keyPressed(keyEvent);
    }

    /**
     * Programmatically simulates a key release event for a given key code. For Testing/AI
     * @param keyCode The virtual key code of the key to simulate releasing.
     */
    public void simulateKeyRelease(int keyCode) {
        KeyEvent keyEvent = new KeyEvent(new java.awt.Component(){}, KeyEvent.KEY_RELEASED, System.currentTimeMillis(), 0, keyCode, KeyEvent.CHAR_UNDEFINED);
        this.keyReleased(keyEvent);
    }
}